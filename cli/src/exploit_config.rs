use anyhow::{Context, Result};
use serde::Deserialize;
use std::path::Path;

#[derive(Debug, Deserialize)]
#[serde(untagged)]
pub enum ChallengeRef {
    Id(i32),
    Name(String),
}

impl ChallengeRef {
    pub fn as_id(&self) -> Option<i32> {
        match self {
            ChallengeRef::Id(id) => Some(*id),
            ChallengeRef::Name(_) => None,
        }
    }

    pub fn as_name(&self) -> Option<&str> {
        match self {
            ChallengeRef::Id(_) => None,
            ChallengeRef::Name(name) => Some(name.as_str()),
        }
    }
}

#[derive(Debug, Default, Deserialize)]
pub struct ExploitConfig {
    #[allow(dead_code)]
    pub name: Option<String>,
    #[serde(alias = "challenge_id", alias = "challenge_name")]
    pub challenge: Option<ChallengeRef>,
    #[serde(alias = "image")]
    pub docker_image: Option<String>,
    pub entrypoint: Option<String>,
    pub priority: Option<i32>,
    #[serde(alias = "max_per_container")]
    pub max_per_container: Option<i32>,
    #[serde(alias = "timeout")]
    pub timeout_secs: Option<i32>,
    pub default_counter: Option<i32>,
    pub enabled: Option<bool>,
}

pub fn load_exploit_config(path: &Path) -> Result<ExploitConfig> {
    let contents = std::fs::read_to_string(path)
        .with_context(|| format!("failed to read exploit config {}", path.display()))?;
    let config = toml::from_str(&contents)
        .with_context(|| format!("failed to parse exploit config {}", path.display()))?;
    Ok(config)
}

pub fn load_default_exploit_config() -> Result<ExploitConfig> {
    let path = std::env::current_dir()?.join("config.toml");
    if path.exists() {
        return load_exploit_config(&path);
    }
    Ok(ExploitConfig::default())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn load_exploit_config_parses_aliases() {
        let dir = TempDir::new().unwrap();
        let cfg = dir.path().join("config.toml");
        fs::write(
            &cfg,
            r#"
name = "demo"
challenge = "chal-1"
image = "demo:latest"
timeout = 30
max_per_container = 2
"#,
        )
        .unwrap();
        let parsed = load_exploit_config(&cfg).unwrap();
        assert_eq!(parsed.name.as_deref(), Some("demo"));
        assert_eq!(parsed.challenge.as_ref().and_then(|c| c.as_name()), Some("chal-1"));
        assert_eq!(parsed.docker_image.as_deref(), Some("demo:latest"));
        assert_eq!(parsed.timeout_secs, Some(30));
        assert_eq!(parsed.max_per_container, Some(2));
    }
}
