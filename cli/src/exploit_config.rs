use anyhow::{Context, Result};
use serde::Deserialize;
use std::path::Path;

#[derive(Debug, Default, Deserialize)]
pub struct ExploitConfig {
    pub name: Option<String>,
    #[serde(alias = "challenge")]
    pub challenge_id: Option<i32>,
    #[serde(alias = "image")]
    pub docker_image: Option<String>,
    pub entrypoint: Option<String>,
    pub priority: Option<i32>,
    #[serde(alias = "max_per_container")]
    pub max_per_container: Option<i32>,
    #[serde(alias = "timeout")]
    pub timeout_secs: Option<i32>,
    pub default_counter: Option<i32>,
    pub enabled: Option<bool>,
}

pub fn load_exploit_config(path: &Path) -> Result<ExploitConfig> {
    let contents = std::fs::read_to_string(path)
        .with_context(|| format!("failed to read exploit config {}", path.display()))?;
    let config = toml::from_str(&contents)
        .with_context(|| format!("failed to parse exploit config {}", path.display()))?;
    Ok(config)
}

pub fn load_default_exploit_config() -> Result<ExploitConfig> {
    let path = std::env::current_dir()?.join("config.toml");
    if path.exists() {
        return load_exploit_config(&path);
    }
    Ok(ExploitConfig::default())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn load_exploit_config_parses_aliases() {
        let dir = TempDir::new().unwrap();
        let cfg = dir.path().join("config.toml");
        fs::write(
            &cfg,
            r#"
name = "demo"
challenge = 1
image = "demo:latest"
timeout = 30
max_per_container = 2
"#,
        )
        .unwrap();
        let parsed = load_exploit_config(&cfg).unwrap();
        assert_eq!(parsed.name.as_deref(), Some("demo"));
        assert_eq!(parsed.challenge_id, Some(1));
        assert_eq!(parsed.docker_image.as_deref(), Some("demo:latest"));
        assert_eq!(parsed.timeout_secs, Some(30));
        assert_eq!(parsed.max_per_container, Some(2));
    }
}
