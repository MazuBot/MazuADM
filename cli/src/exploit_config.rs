use anyhow::{Context, Result};
use serde::Deserialize;
use std::path::Path;

#[derive(Debug, Deserialize)]
#[serde(untagged)]
pub enum ChallengeRef {
    Name(String),
}

impl ChallengeRef {
    pub fn as_name(&self) -> Option<&str> {
        match self { ChallengeRef::Name(name) => Some(name.as_str()) }
    }
}

#[derive(Debug, Default, Deserialize)]
pub struct ExploitConfig {
    #[serde(alias = "challenge_id", alias = "challenge_name")]
    pub challenge: Option<ChallengeRef>,
    #[serde(alias = "image")]
    pub docker_image: Option<String>,
    pub entrypoint: Option<String>,
    pub max_per_container: Option<i32>,
    pub max_concurrent_jobs: Option<i32>,
    #[serde(alias = "timeout")]
    pub timeout_secs: Option<i32>,
    pub default_counter: Option<i32>,
    pub ignore_connection_info: Option<bool>,
    pub enabled: Option<bool>,
}

pub fn load_exploit_config(path: &Path) -> Result<ExploitConfig> {
    let contents = std::fs::read_to_string(path)
        .with_context(|| format!("failed to read config {}", path.display()))?;
    toml::from_str(&contents).with_context(|| format!("failed to parse {}", path.display()))
}

pub fn load_default_exploit_config() -> Result<ExploitConfig> {
    let path = std::env::current_dir()?.join("config.toml");
    if path.exists() { load_exploit_config(&path) } else { Ok(ExploitConfig::default()) }
}
